(define (rec-merge-n l r n)
  (define (merger left right index merging-left)
    (let ((next-merging-left (if (zero? (modulo index n)) (not merging-left) merging-left)))
      (cond ((and merging-left (pair? left)) (cons (car left) (merger (cdr left) right (+ index 1) next-merging-left)))
            ((pair? right) (cons (car right) (merger left (cdr right) (+ index 1) next-merging-left)))
            (else '()))))
  (merger l r 1 #t))

(define (iter-merge-n l r n)
  (define (merger collection left right index merging-left)
    (let ((next-merging-left (if (zero? (modulo index n)) (not merging-left) merging-left)))
      (cond ((and merging-left (pair? left)) (merger (cons (car left) collection) (cdr left) right (+ index 1) next-merging-left))
            ((pair? right) (merger (cons (car right) collection) left (cdr right) (+ index 1) next-merging-left))
            (else collection))))
  (reverse (merger '() l r 1 #t)))

(rec-merge-n '(1 2 3 4 5) '(6 7 8 9) 2)
(rec-merge-n '(1 2 3 4 5) '(6 7 8 9) 3)
(rec-merge-n '(1 2) '(3 4 5 6) 4)
(iter-merge-n '(1 2 3 4 5) '(6 7 8 9) 2)
(iter-merge-n '(1 2 3 4 5) '(6 7 8 9) 3)
(iter-merge-n '(1 2) '(3 4 5 6) 4)
